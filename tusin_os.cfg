GLOBAL {
	inputname "Disk Control Program.fds";
	outputname "tusin_os.s";
	inputoffs $014c;
	inputsize $2000;
	startaddr $c000;
	cpu "6502";
	comments 3;
};

# One segment for the whole stuff
segment { start $e000; end $ffff; name "disksys"; };

# Hardware defines

## FC
label { name "PPU_CTRL"; addr $2000; };
label { name "PPU_MASK"; addr $2001; };
label { name "PPU_STATUS"; addr $2002; };
label { name "PPU_OAMADDR"; addr $2003; };
label { name "PPU_OAMDATA"; addr $2004; };
label { name "PPU_SCROLL"; addr $2005; };
label { name "PPU_ADDR"; addr $2006; };
label { name "PPU_DATA"; addr $2007; };

label { name "APU_PULSE1"; addr $4000; size 4; };
label { name "APU_PULSE2"; addr $4004; size 4; };
label { name "APU_TRI"; addr $4008; size 4; };
label { name "APU_NOISE"; addr $400C; size 4; };

label { name "DMC_FREQ"; addr $4010; };
label { name "DMC_RAW"; addr $4011; };
label { name "DMC_START"; addr $4012; };
label { name "DMC_LEN"; addr $4013; };

label { name "OAM_DMA"; addr $4014; };

label { name "APU_STATUS"; addr $4015; };

label { name "JOY1"; addr $4016; };
label { name "JOY2"; addr $4017; };

## FDS
label { name "FDS_IRQ_TIMER"; addr $4020; size 2; };
label { name "FDS_IRQ_TIMER_CTRL"; addr $4022; };

label { name "FDS_IO_ENABLE"; addr $4023; };

label { name "FDS_WRITE_DATA"; addr $4024; };

label { name "FDS_CTRL"; addr $4025; };

label { name "FDS_EXT_OUT"; addr $4026; };

label { name "FDS_STATUS"; addr $4030; };

label { name "FDS_READ_DATA"; addr $4031; };

label { name "FDS_DRIVE_STATUS"; addr $4032; };

label { name "FDS_EXT_IN"; addr $4033; };

# Zero-page variables
label { name "tempzp"; addr $00; size 16; };
label { name "joypad"; addr $f1; size 8; };

## Register mirrors
label { name "FDS_EXT_Mirror"; addr $f9; };
label { name "FDS_CTRL_Mirror"; addr $fa; };
label { name "JOY1_Mirror"; addr $fb; };
label { name "Y_SCROLL_Mirror"; addr $fc; };
label { name "X_SCROLL_Mirror"; addr $fd; };
label { name "PPU_MASK_Mirror"; addr $fe; };
label { name "PPU_CTRL_Mirror"; addr $ff; };

# Stack
label { name "NMI_FLAG"; addr $0100; };
label { name "IRQ_FLAG"; addr $0101; };
label { name "RESET_FLAG"; addr $0102; };
label { name "RESET_TYPE"; addr $0103; };

# RAM
label { name "VRAMBuffer_Size"; addr $0300; };
label { name "VRAMBuffer_End"; addr $0301; };
label { name "VRAMBuffer"; addr $0302; size 253; };

# Data
range { start $e000; end $e000; type ByteTable; };
range { name "CHRData"; start $e001; end $e148; type ByteTable; };
range { name "FDSStr"; start $e6d5; end $e6e2; type TextTable; };
range { name "Kyodaku"; start $ed37; end $ee16; type ByteTable; };

range { name "FileList"; start $eff5; end $effe; type ByteTable; };

range { name "Unk_Data"; start $efff; end $f0b3; type ByteTable; };

range { start $f175; end $f178; type ByteTable; };

range { start $f2e8; end $f2eb; type ByteTable; };

range { start $f36e; end $f375; type ByteTable; };

range { start $f484; end $f48b; type ByteTable; };

range { start $f56b; end $f5b7; type ByteTable; };

range { start $f635; end $fe35; type ByteTable; };

range { start $ff00; end $ff5b; type ByteTable; };
range { start $ff6f; end $ff7a; type ByteTable; };
range { start $fff6; end $fff9; type ByteTable; };
range { name "Vectors"; start $fffa; end $ffff; type AddrTable; };

# Routines

## Disk I/O
label { name "LoadFiles"; addr $e1f8; }; #paramsize 4; };
label { name "AppendFile"; addr $e237; }; #paramsize 4; };
label { name "WriteFile"; addr $e239; }; #paramsize 4; };
label { name "CheckFileCount"; addr $e2b7; }; #paramsize 2; };
label { name "AdjustFileCount"; addr $e2bb; paramsize 2; };
label { name "SetFileCount1"; addr $e301; paramsize 2; };
label { name "SetFileCount"; addr $e305; paramsize 2; };
label { name "GetDiskInfo"; addr $e32a; paramsize 2; };

## Low-level disk I/O
label { name "WriteLastFile"; addr $e26b; };
label { name "CheckLastFile"; addr $e290; };

label { name "SetFileCnt"; addr $e2ab; };
label { name "GetFileCount"; addr $e2f7; };

label { name "FetchDiskPtrs"; addr $e3e7; };
label { name "FetchDiskPtrs_WriteProtectCheck"; addr $e3ea; };

label { name "CheckDiskHeader"; addr $e445; };
label { name "GetNumFiles"; addr $e484; };
label { name "SetNumFiles"; addr $e492; };
label { name "FileMatchTest"; addr $e4a0; };
label { name "SkipFiles"; addr $e4da; };

label { name "LoadData"; addr $e4f9; };
label { name "ReadData"; addr $e506; };
label { name "SaveData"; addr $e5b5; };

label { name "WaitForReady"; addr $e64d; };

label { name "StopMotor"; addr $e685; };
label { name "StartMotor"; addr $ee17; };

label { name "CheckBlockType"; addr $e68f; };
label { name "WriteBlockType"; addr $e6b0; };

label { name "StartXfer"; addr $e6e3; };

label { name "EndOfBlockRead"; addr $e706; };
label { name "EndOfBlockWrite"; addr $e729; };

label { name "CheckDiskSet"; addr $e74c; };

label { name "ReadCRC_Unused"; addr $e761; };

label { name "Xfer1stByte"; addr $e794; };
label { name "XferByte"; addr $e7a3; };

### Disk transfer return states
label { name "XferDone"; addr $e778; };
label { name "XferFailOnCarry"; addr $e77c; };
label { name "XferFailOnNEQ"; addr $e77f; };
label { name "XferFail"; addr $e781; };

### Low-level helpers
label { name "AddYtoPtr0A"; addr $e3da; };
label { name "LoadSizeAndSrc"; addr $e583; };
label { name "Inc0ADec0C"; addr $e7a7; };
label { name "Dec0C"; addr $e7ad; };

## General purpose
label { name "Delay131"; addr $e149; };
label { name "Delayms"; addr $e153; };

label { name "DisPFObj"; addr $e161; };
label { name "EnPFObj"; addr $e16b; };
label { name "DisObj"; addr $e171; };
label { name "EnObj"; addr $e178; };
label { name "DisPF"; addr $e17e; };
label { name "EnPF"; addr $e185; };

label { name "VINTWait"; addr $e1b2; };
label { name "VRAMStructWrite"; addr $e7bb; paramsize 2; };
label { name "FetchDirectPtr"; addr $e844; };
label { name "WriteVRAMBuffer"; addr $e86a; };
label { name "ReadVRAMBuffer"; addr $e8b3; };
label { name "PrepareVRAMString"; addr $e8d2; paramsize 2; };
label { name "PrepareVRAMStrings"; addr $e8e1; paramsize 2; };
label { name "GetVRAMBufferByte"; addr $e94f; };
label { name "Pixel2NamConv"; addr $e97d; };
label { name "PNam2PixelConv"; addr $e997; };

label { name "Random"; addr $e9b1; };
label { name "SpriteDMA"; addr $e9c8; };
label { name "CounterLogic"; addr $e9d3; };

label { name "ReadPads"; addr $e9eb; };
label { name "OrPads"; addr $ea0d; };
label { name "ReadDownPads"; addr $ea1a; };
label { name "ReadOrDownPads"; addr $ea1f; };
label { name "ReadDownVerifyPads"; addr $ea36; };
label { name "ReadOrDownVerifyPads"; addr $ea4c; };
label { name "ReadDownExpPads"; addr $ea68; };

label { name "VRAMFill"; addr $ea84; };
label { name "MemFill"; addr $ead2; };

label { name "SetScroll"; addr $eaea; };

### Jump table implementation uses an inline pointer table of an arbitrary size, 
### which can't be represented here...
label { name "JumpEngine"; addr $eafd; };

label { name "ReadKeyboard"; addr $eb13; };

label { name "LoadTileset"; addr $ebaf; paramsize 2; };

label { name "UploadObject"; addr $ec22; };

label { name "LoadFonts"; addr $f1c3; };

# Disk game vectors
range {name "Vectors"; start $dff6; end $dfff; type addrtable; };
label { name "NMI_1"; addr $de5e; };
label { name "NMI_2"; addr $ded3; };
label { name "NMI_3"; addr $c800; };
label { name "Reset"; addr $c83f; };

# Data
range { start $c123; end $c124; type addrtable; };
range { start $cd7e; end $cd7f; type addrtable; };
range { start $c151; end $c154; type addrtable; };
range { start $cc1c; end $cc1f; type addrtable; };
range { start $d8d1; end $d8d4; type addrtable; };
range { start $d8e5; end $d8e8; type addrtable; };
range { start $c9f0; end $c9f1; type addrtable; };
range { start $caaa; end $caab; type addrtable; };
range { start $cbc7; end $cbc8; type addrtable; };
range { start $cd56; end $cd57; type addrtable; };
range { start $cac1; end $cac4; type addrtable; };

range { start $c167; end $c168; type code; };
range { start $c1ae; end $c1ca; type bytetable; };
range { start $c6b1; end $c6b8; type bytetable; };
range { start $c6dc; end $c6de; type code; };
range { start $c812; end $c814; type code; };
range { start $c93d; end $c965; type code; };
range { start $c9e0; end $c9e1; type code; };
range { start $ce95; end $cfb0; type bytetable; };
range { start $d102; end $d104; type code; };
range { start $d24b; end $d25c; type code; };
range { start $d2b6; end $d2fa; type code; };
range { start $d62d; end $d6ee; type bytetable; };
range { start $d70c; end $d723; type bytetable; };
range { start $d80b; end $d80f; type bytetable; };
range { start $d8a2; end $d8b9; type bytetable; };
range { start $d91a; end $d91d; type addrtable; };
range { start $d9af; end $d9fb; type bytetable; };
range { start $dada; end $dadf; type addrtable; };
range { start $db34; end $db5e; type bytetable; };
range { start $db9f; end $dbf0; type bytetable; };
range { name "PaletteDataPtr"; start $dde9; end $ddea; type addrtable; };
range { name "PaletteData"; start $ddee; end $de0d; type bytetable; };
range { start $dfbf; end $dfdc; type code; };
range { start $dfdd; end $dff5; type bytetable; };

# Variables
label {name "SerialByte"; addr $73; comment "Used for both serial reads & writes"; };
label {name "PaletteArray"; addr $c0; size 32; };
label {name "Command"; addr $e0; };
label {name "CommandFlag"; addr $e1; comment "must be nonzero for commands to be executed?"; };
label {name "NMIVar"; addr $f0; comment "frame timer, decremented by NMI handlers"; };

label {name "DiskCapacity"; addr $d80c; size 2; comment "big endian"; };
label {name "DiskFlag"; addr $d80f; comment "$FF = disk ejected, Others = disk inserted"; };
label {name "NewFileCount"; addr $dfca; };

# Routines
label { name "Check_CMD_DiskDelete"; addr $ccc7; };
label { name "CMD_DiskDelete"; addr $ccd0; comment "10-DISK DELETE: Delete files from the inserted disk and update the directory.
; This is done by simply altering the file count.
; Parameter: $DFCA = new file count <= original file count, otherwise error 31 is thrown"; };

label { name "Check_CMD_DiskSave"; addr $cb38; };
label { name "CMD_DiskSave"; addr $cb41; comment "20-DISK SAVE: Save a file to the inserted disk and update the directory.
; Parameters: $DF08 = File ID copied to $DFCB, $6000-$600E = File Header struct copied to $DFCC
; Note that File ID = DiskFlag and files with ID $FF can never be read by the BIOS."; };

label { name "Check_CMD_Directory"; addr $c966; };
label { name "CMD_Directory"; addr $c96f; comment "40-DIRECTORY: Read the current disk's directory into $D800.
; Directory Format:
; - 13 bytes from disk info block, disk capacity (16-bit, big endian), file count
; - for each file: file header block contents w/ a $00 byte between File Address & File Size"; };

label { name "Check_CMD_DiskLoad"; addr $ca1e; };
label { name "CMD_DiskLoad"; addr $ca27; comment "80-DISK LOAD: Perform a File Header match test on the current disk's files.
; The last matching File Header struct is loaded into $6000 and its File Data is loaded into $6010."; };

label { name "ClearRAM"; addr $cfbc; };
label { name "FetchDiskDirectory"; addr $cfe8; comment "Actual implementation of the directory command.
; Fetch the disk directory and place it at the specified inline pointer.
; Inline Parameter: Destination Address"; }; #paramsize 2; };
label { name "WaitForNMI"; addr $cfb1; };
label { name "LoadDisk"; addr $d0a1; comment "Actual implementation of the disk load command.
; Load the current disk's contents based on the two structures specified by inline pointers.
; Inline Parameters: Disk ID pointer, File Header pointer"; }; #paramsize 4; };
label { name "WaitForZeroCMD"; addr $dcd5; comment "Decrement Command, then wait until Command == 0"; };

label { name "ReceiveByte"; addr $d14a; comment "Receive 2 nybbles from $4017.D4..1 (%00011110) into SerialByte, upper nybble first"; };
label { name "TransmitByte"; addr $d1a1; comment "Transmit 8 bits in serial from SerialByte to $4016.D2 (%00000100), D0 first
; (SerialByte is cleared in the process)"; };
label { name "SerialXfer"; addr $d1f3; comment "Some kind of serial transfer protocol"; };
label {name "CheckSerialMode"; addr $d1fb; comment "Disable NMIs, read a serial byte, then branch to one of 3 serial modes
; (0-2 are valid, 3 onwards is ignored)"; };
label {name "SerialMode_ReceiveData"; addr $d234; comment "Serial Mode 0: Receive serial data into a specified CPU address.
; Input format: length, destination address hi, destination address lo, data"; };
label {name "SerialMode_TransmitData"; addr $d258; comment "Serial Mode 1: Transmit serial data from a specified CPU address.
; Input format: length, source address hi, source address lo
; Output format: data"; };
label {name "SerialMode_ReceivePackets"; addr $d281; comment "Serial Mode 2: Receive multiple mode 0 packets until a length = 0 byte is read.
; The disk drive is also checked for ejected disks during the process for some reason.
; Input format: [length, destination address hi, destination address lo, data]"; };

label {name "SerialExit_EnableNMI"; addr $d22a; comment "Not sure why a near-identical routine is used here";};
label {name "DisableNMI"; addr $cfd4; };
label {name "EnableNMI"; addr $cfde; };

label {name "HandleControllers"; addr $d2b6; comment "Perform a DMC-safe controller reread loop, then perform operations on the button reports.
; Probably for press/hold/release handling?"; };
label {name "ReadJoypads"; addr $d34b; };

label { name "ReadPaletteData"; addr $dd83; comment "Fetches 32 bytes from inline pointer and puts them into the palette array at $C0"; };
label { name "FetchInlinePtr"; addr $dd93; };
label { name "UpdatePalettes"; addr $dde6; };


